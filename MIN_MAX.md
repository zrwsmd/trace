# MinMaxDownsampler 示例（保留首尾 + 桶内 Min/Max）

## 场景设定

- 原始数据（12 个点）：

```text
[(0, 5), (1, 8), (2, 9), (3, 6), (4, 2), (5, 1),
 (6, 4), (7, 7), (8, 3), (9, 5), (10, 8), (11, 6)]
```

- 这是一个 **M 型波**：包含一个明显高峰与一个明显低谷。
- 降采样目标：`threshold = 6`（期望输出 6 个点）。

---

## 新代码执行流程

### 第 1 步：初始化并添加第一个点

1. 代码首先识别出第一个点 `(0, 5)` 和最后一个点 `(11, 6)`。
2. 立即将第一个点 `(0, 5)` 加入最终结果列表 `sampledPoints`。

当前 `sampledPoints`：

```text
[(0, 5)]
```

---

### 第 2 步：处理中间数据

1. 处理中间的 10 个点（索引 1 到 10）：

```text
[(1, 8), (2, 9), (3, 6), (4, 2), (5, 1),
 (6, 4), (7, 7), (8, 3), (9, 5), (10, 8)]
```

2. 中间数据分配的目标点数：`threshold - 2 = 6 - 2 = 4`。
3. 由于每个桶输出 2 个点（min + max），因此桶数：`4 / 2 = 2`。
4. 每个桶的大小：`10 / 2 = 5` 个点。

---

#### 处理第一个桶

- 桶内数据：

```text
[(1, 8), (2, 9), (3, 6), (4, 2), (5, 1)]
```

- 寻找极值：
  - `minPoint`（Y 最小）：`(5, 1)`
  - `maxPoint`（Y 最大）：`(2, 9)`

- 按时间顺序添加：比较 X 坐标，`maxPoint.x = 2` 小于 `minPoint.x = 5`，所以先添加 `maxPoint` 再添加 `minPoint`。

当前 `sampledPoints`：

```text
[(0, 5), (2, 9), (5, 1)]
```

---

#### 处理第二个桶

- 桶内数据：

```text
[(6, 4), (7, 7), (8, 3), (9, 5), (10, 8)]
```

- 寻找极值：
  - `minPoint`（Y 最小）：`(8, 3)`
  - `maxPoint`（Y 最大）：`(10, 8)`

- 按时间顺序添加：比较 X 坐标，`minPoint.x = 8` 小于 `maxPoint.x = 10`，所以先添加 `minPoint` 再添加 `maxPoint`。

当前 `sampledPoints`：

```text
[(0, 5), (2, 9), (5, 1), (8, 3), (10, 8)]
```

---

### 第 3 步：添加最后一个点

1. 代码检查 `sampledPoints` 的最后一个点 `(10, 8)` 是否等于预先保存的最后一个点 `(11, 6)`。
2. 二者不相等，因此将 `(11, 6)` 追加到列表末尾。

---

## 最终结果

最终 `sampledPoints`：

```text
[(0, 5), (2, 9), (5, 1), (8, 3), (10, 8), (11, 6)]
```

### 效果分析

- ✅ 保留首尾：强制包含 `(0, 5)` 与 `(11, 6)`。
- ✅ 保留极值：捕捉到峰值 `(2, 9)` 与谷值 `(5, 1)`。
- ✅ 行为一致：边界处理与 LTTB 的“保留首尾”逻辑一致，有利于两种算法切换时的平滑过渡。

# 工业级自适应降采样算法设计文档 (v5.0)

## 1. 核心概述

`AdaptiveDownsamplingSelector` 是一套基于**信号特征识别**与**动态资源分配**的混合降采样引擎。与传统单一算法（如单纯的 LTTB
或 Min-Max）不同，它能够识别信号的数学特征，并根据压缩倍率动态切换最优的处理策略，确保“**微观形状不失真，宏观包络不丢失**”。

## 2. 算法流水线 (Pipeline)

算法执行分为五个核心阶段：

1. **全局评估**：计算总点数与目标点数的压缩比（Compression Ratio）。
2. **分块分析**：根据压缩比动态调整窗口大小（Adaptive Window），并提取各窗口的数学特征。
3. **资源配额分配**：根据窗口的“信息熵”（复杂度）分配采样点数，并执行最小密度保护。
4. **算法匹配执行**：为每个窗口匹配最适合的降采样算法。
5. **结果归一化**：通过补点（Gap Filling, v5.0 改用中点优先策略）或裁剪，确保输出点数精确等于预期。

## 3. 信号特征提取 (Feature Extraction)

系统通过 `SignalFeatures` 结构体捕捉信号的深度指纹：

* **波动性 (Volatility)**：归一化的一阶差分均值，衡量信号的活跃程度，对振幅不敏感。
* **线性度 (Linearity)**：基于 R² 拟合优度，判断信号是否趋于直线。
* **周期性 (Periodicity)**：利用自相关函数检测重复模式及其周期长度。
* **突变检测 (Step/Pulse)**：通过一阶导数识别阶跃和脉冲。
* **包络特征 (Envelope Growth)**：专门识别调幅信号（如振幅线性增长的正弦波）。

### 3.1 信号特征字段详解 (SignalFeatures)

系统通过以下指标为信号进行“画像”：

| 字段                       | 名称     | 详细说明                                                               |
|:-------------------------|:-------|:-------------------------------------------------------------------|
| **mean**                 | 均值     | 数据点的平均值，用于确定信号的基准线（Baseline）。                                      |
| **stdDev**               | 标准差    | 衡量数据的离散程度。值越大，说明信号相对于基准线的波动越剧烈。                                    |
| **range**                | 值域     | 数据集的极差（Max - Min），反映信号覆盖的物理跨度。                                     |
| **volatility**           | 绝对波动率  | 计算为“总行程 / 值域”，衡量信号在垂直方向上的累计变动量。                                    |
| **normalizedVolatility** | 归一化波动率 | **核心指标**。衡量相邻点变化的百分比。它对振幅不敏感，是判断信号活跃度的重要标准。                        |
| **flatness**             | 平坦度    | 标准差与值域的比值。值极小时，说明信号几乎是一条平滑的直线。                                     |
| **linearity**            | 线性度    | 基于 R²（拟合优度）计算，值越接近 1.0 说明信号越趋于线性增长或减少。                             |
| **trendSlope**           | 趋势斜率   | 通过线性回归计算出的斜率，反映信号整体的宏观上升或下降趋势。                                     |
| **periodicity**          | 周期性强度  | 通过自相关函数计算，值越高说明信号具有越明显的重复规律（如正弦波）。                                 |
| **autocorrelation**      | 自相关系数  | 衡量信号与其自身在一定延迟后的相似度，辅助判断信号的自相关特性。                                   |
| **stepCount**            | 阶跃次数   | 检测信号中突然大幅跳变的频率，用于识别开关量信号或阶跃响应。                                     |
| **noiseRatio**           | 噪声比    | 通过分析二阶导数（加速度）来衡量高频随机波动的占比，用于识别信号纯净度。                               |
| **zeroCrossings**        | 过零率    | 信号穿过基准线（均值）的次数，辅助判断高频振荡特性。                                         |
| **maxAbsDerivative**     | 最大瞬时变率 | 相邻两点间最大的绝对变化量，用于捕捉脉冲（Pulse）或阶跃（Step）的瞬间跳变。                         |
| **estimatedPeriod**      | 预估周期   | 基于自相关分析估算出的信号周期长度（单位：点数），仅在 periodicity 高时有效。                      |
| **residualStdDev**       | 残差标准差  | 移除线性趋势后数据的标准差，用于衡量去势后的纯波动幅度。                                       |
| **detrendedRange**       | 去势值域   | 移除线性趋势后数据的极差，配合 trendStrength 判断信号是否由趋势主导。                         |
| **trendStrength**        | 趋势强度   | 线性趋势对信号整体幅度的贡献占比（0~1），值越高说明信号主要体现为上升或下降趋势。                         |
| **envelopeGrowthRatio**  | 包络增长率  | 信号振幅随时间变化的增长比率，专门用于识别“喇叭口”形状的调幅信号（SignalType.AMPLITUDE_MODULATED）。 |

## 4. 信号分类 (SignalType)

系统根据提取的特征，将输入信号划分为以下 9 种类型，作为算法选择的基础：

| 信号类型                    | 名称     | 判定逻辑 / 特征说明                | 典型场景         |
|:------------------------|:-------|:---------------------------|:-------------|
| **FLAT**                | 平坦信号   | 平坦度（flatness）低。            | 传感器待机、零位信号。  |
| **LINEAR**              | 线性信号   | 线性度（linearity）高且噪声比低。      | 匀速升温、匀速位移。   |
| **PERIODIC**            | 周期信号   | 周期性强度（periodicity）高。       | 标准正弦波、转速信号。  |
| **AMPLITUDE_MODULATED** | 调幅周期信号 | 具有明显周期性，且振幅随时间呈增长趋势。       | 电机启动、震荡发散过程。 |
| **STEP**                | 阶跃信号   | 检测到显著的瞬时跳变。                | 开关合闸、负载突变。   |
| **PULSE**               | 脉冲信号   | 短时间内出现数次高频波动且波动率大。         | 尖峰干扰、电火花。    |
| **NOISE**               | 高噪声信号  | 波动率极高且噪声比超过阈值。             | 传感器干扰、气流扰动。  |
| **TREND_NOISE**         | 带趋势噪声  | 具有宏观斜率（trendSlope）且伴随高频噪声。 | 带负载运行中的震动。   |
| **COMPLEX**             | 复杂信号   | 不符合上述单一特征的组合信号。            | 多种信号叠加的原始信号。 |

## 5. 动态资源分配策略 (Weighting & Allocation)

这是算法解决“波形稀疏”的关键。

### 4.1 权重计算公式

每个窗口的权重 $W$ 由多维度累加而成：
$$W = \text{Base}(0.3) + \text{Volatility} \times 1.2 + \text{ComplexityBonus} + \text{SpikeBonus} + \text{PeriodicityBonus}$$

* **劫富济贫**：复杂的震荡区域（高 $W$）会从平坦区域（低 $W$）“夺取”更多的采样点数配额。

### 4.2 安全保底约束

* **最小密度保护**：每个窗口强制保留至少 2% 的原始点，防止长周期查询时出现视觉断层。
* **稀疏度控制**：窗口最大稀疏度限制在 50% 以内。

## 6. 算法库与决策逻辑

### 6.1 八大核心算法

1. **KEEP_FIRST_LAST**：用于 `FLAT` 信号，极致压缩。
2. **LTTB**：中低压缩比下的首选，保持最佳几何视觉形态。
3. **MIN_MAX**：高压缩比下的噪声处理，保证峰值可见。
4. **UNIFORM**：等距采样，作为基础填充。
5. **PEAK_DETECTION**：用于阶跃和脉冲，锁定物理拐点。
6. **ADAPTIVE_LTTB**：复杂组合信号的二次加权处理。
7. **HYBRID_ENVELOPE (v4.0 核心)**：
    * **40% 极值**：勾勒上下包络。
    * **30% 中心带**：采样均值点，防止中间掏空。
    * **30% 形状点**：填充细节。
8. **UNIFORM_WITH_EXTREMES (v5.0 核心)**：
   * **极值保护**：强制保留全局 Max/Min 及局部显著极值点（约 15% 配额）。
   * **均匀采样**：在剩余空间执行均匀步长采样，解决噪声数据聚集问题。

### 6.2 决策矩阵 (Decision Logic)

系统根据**压缩比** (Compression Ratio = Input / Target) 和 **信号类型** (SignalType) 共同决定采用哪种算法：

#### A. 高压缩比场景 (Compression > 10.0)

此时主要目标是**保留极值和包络**，防止因点数过少导致波形消失。

| 信号类型                                      | 采用算法                    | 理由                                 |
|:------------------------------------------|:------------------------|:-----------------------------------|
| **PERIODIC** / **AMPLITUDE_MODULATED**    | `HYBRID_ENVELOPE`       | 确保显示出完整的波形包络带，避免混叠。                |
| **NOISE** / **TREND_NOISE** / **COMPLEX** | `UNIFORM_WITH_EXTREMES` | **v5.0 新策略**。强制均匀分布并保留极值，防止噪声聚集成团。 |
| **LINEAR** (线性度 > 0.99)                   | `LTTB`                  | 极高线性度下，LTTB 能最完美地保持直线特征。           |
| **其他**                                    | `MIN_MAX`               | 兜底方案，确保最大最小范围可见。                   |

#### B. 低压缩比场景 (Compression <= 10.0)

此时有足够的点数预算来展示细节，优先进入**形状优先模式**。

| 信号类型                                   | 采用算法                    | 理由                                  |
|:---------------------------------------|:------------------------|:------------------------------------|
| **PERIODIC** / **AMPLITUDE_MODULATED** | `HYBRID_ENVELOPE`       | 依然优先保持包络形状。                         |
| **NOISE** / **TREND_NOISE**            | `UNIFORM_WITH_EXTREMES` | **v5.0 新策略**。解决 LTTB 在噪声数据下分布不均的问题。 |
| **COMPLEX**                            | `ADAPTIVE_LTTB`         | 对于非噪声的复杂信号，尝试用自适应分桶保留更多几何细节。        |
| **STEP** / **PULSE**                   | `PEAK_DETECTION`        | 确保 100% 捕捉到每一个跳变沿和尖峰。               |
| **LINEAR** / **FLAT** / **其他**         | `LTTB`                  | 经典的面积最大化算法，视觉效果最佳。                  |

## 7. 结果精准化 (Normalization)

为了满足前端图表控件对点数的精确要求，算法最后执行：

* **智能补点 (Fill Gaps, v5.0)**：识别时间轴上最大的时间空隙（Gap），**优先选择中点位置的点**，并支持大 Gap 的 1/4、3/4 处均匀补点。
* **等距裁剪 (Uniform Trim)**：如果点数超出，利用步长算法进行无偏裁剪。

## 8. 典型应用场景表现

* **调幅正弦波 (r0)**：在长达数小时的全局视图下，`HYBRID_ENVELOPE` 确保波形呈现为实心的包络带，无条纹和稀疏感。
* **阶跃信号**：`PEAK_DETECTION` 确保开关跳变的瞬间点被 100% 保留。
* **静态信号 (r1, r2)**：几乎不占用采样配额，将资源全部留给动态变量。

---
**版本说明**：v5.0 重点引入了 `UNIFORM_WITH_EXTREMES` 算法，解决了高波动/噪声数据在极端压缩情况下的视觉聚集与极值丢失问题。

---

## 9. HYBRID_ENVELOPE vs UNIFORM_WITH_EXTREMES 深度对比

### 9.1 核心设计理念对比

两个算法虽然都是 v4.0/v5.0 的核心算法,但设计目标和实现策略完全不同:

| 维度       | **HYBRID_ENVELOPE**                      | **UNIFORM_WITH_EXTREMES**             |
|----------|------------------------------------------|---------------------------------------|
| **设计目标** | 保留周期性信号的**完整波形包络**                       | 保留极值点 + **时间轴均匀分布**                   |
| **适用场景** | 周期性/振荡信号 (PERIODIC, AMPLITUDE_MODULATED) | 噪声/复杂信号 (NOISE, TREND_NOISE, COMPLEX) |
| **核心策略** | 三层混合采样 (包络 + 中心带 + 填充)                   | 极值保护 + 均匀填充                           |
| **引入版本** | v4.0                                     | v5.0                                  |
| **主要优势** | 波形包络完整,视觉效果好                             | 极值不丢失,分布均匀                            |
| **主要劣势** | 时间分布可能不均                                 | 包络保护不如前者                              |

### 9.2 算法实现细节对比

#### 9.2.1 HYBRID_ENVELOPE 实现逻辑

**三层混合策略**:

```java
// 配额分配
int envelopeQuota = (int) (targetCount * 0.40);  // 40% → 包络点
int centerQuota = (int) (targetCount * 0.30);  // 30% → 中心带点
int fillerQuota = targetCount - envelopeQuota - centerQuota;  // 30% → 填充点

// 第一层: MinMax 包络采样
List<UniPoint> envelope = MinMaxDownsampler.downsample(data, envelopeQuota);

// 第二层: 中心带采样 (接近均值的点)
List<UniPoint> centralBand = sampleCentralBand(data, centerQuota);

// 第三层: 填充采样 (LTTB 或均匀)
List<UniPoint> filler = noisy ? LTTB : uniform;

// 合并去重
Set<UniPoint> merged = envelope + centralBand + filler;
```

**特点**:

- ✅ **包络完整**: 40%配额专门用于保留每个周期的峰谷
- ✅ **中心趋势**: 30%配额保留信号的"骨干"部分
- ✅ **视觉美观**: 波形连续,适合周期性信号展示
- ❌ **分布不均**: 可能在某些时间段点密集,某些稀疏

---

#### 9.2.2 UNIFORM_WITH_EXTREMES 实现逻辑

**五步极值保护策略**:

```java
// 第一步: 识别全局极值
UniPoint globalMin, globalMax;

// 第二步: 识别局部极值 (15%配额)
int localExtremeQuota = (int) (targetCount * 0.15);
List<PointImportance> localExtremes = detectLocalExtremes();
localExtremes.

sort(byImportance);  // 按显著性排序

// 第三步: 构建必保点集
Set<Integer> mustKeep = {首点, 尾点, globalMin, globalMax, 重要局部极值};

// 第四步: 均匀填充剩余配额
int uniformQuota = targetCount - mustKeep.size();
double step = dataSize / (uniformQuota + 1);
for(
int i = 1;
i <=uniformQuota;i++){
int index = (int) (i * step);
    mustKeep.

add(index);
}

// 第五步: 排序返回
        return

sortedPoints(mustKeep);
```

**特点**:

- ✅ **极值不丢**: 全局极值 + 15%重要局部极值永远保留
- ✅ **分布均匀**: 剩余点均匀分布在时间轴上
- ✅ **避免聚集**: 解决了 LTTB 在噪声数据上的点聚合问题
- ❌ **包络不全**: 只保留15%局部极值,可能丢失部分周期的峰谷

### 9.3 为什么不能相互替代?

#### 9.3.1 包络保护能力的差异

**场景**: 10个周期的正弦波, 1000点 → 100点

**HYBRID_ENVELOPE 表现**:

```
40个包络点 → 每个周期约4个包络点 (10周期 × 4点 = 40点)
30个中心点 → 每个周期约3个中心点 (10周期 × 3点 = 30点)
30个填充点 → 补充细节

结果: 每个周期都有清晰的波峰波谷,波形完整
```

**UNIFORM_WITH_EXTREMES 表现**:

```
2个全局极值 → 最高峰 + 最低谷
15个局部极值 → 15% × 100 = 15个点 (可能只覆盖3-4个周期的峰谷)
83个均匀点 → 均匀分布

结果: 部分周期的峰谷丢失,波形不连续
```

**结论**: 对于周期性信号,UNIFORM_WITH_EXTREMES 的15%局部极值配额**不足以覆盖所有周期**。

---

#### 9.3.2 中心带采样的重要性

**HYBRID_ENVELOPE** 专门设计了 **30%配额** 用于中心带采样:

```java
// 在每个 bucket 内寻找最接近均值的点
List<UniPoint> sampleCentralBand(List<UniPoint> data, int quota) {
    for (int i = 0; i < bucketCount; i++) {
        // 找到最接近均值的点
        UniPoint closestToMean = findClosestToMean(bucket);
        selected.add(closestToMean);
    }
}
```

这对于**调幅信号** (AMPLITUDE_MODULATED) 非常重要:

- 调幅信号的振幅随时间变化
- 中心带采样能保留信号的"骨干"趋势
- UNIFORM_WITH_EXTREMES 没有这个机制,只有均匀采样

**示例**: 振幅线性增长的正弦波

```
原始信号: ∿ ∿∿ ∿∿∿ ∿∿∿∿ ∿∿∿∿∿  (振幅逐渐增大)

HYBRID_ENVELOPE:
- 包络线: 勾勒出上下边界的增长趋势
- 中心带: 保留中心线的变化
- 结果: 清晰展示振幅增长

UNIFORM_WITH_EXTREMES:
- 只保留最大峰和最小谷
- 缺少中间过渡的振幅信息
- 结果: 振幅增长趋势不明显
```

---

#### 9.3.3 视觉效果对比

**周期性信号降采样效果**:

```
原始波形 (1000点):
∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿

HYBRID_ENVELOPE (100点):
∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿
↑ 每个周期都有清晰的波峰波谷,波形连续

UNIFORM_WITH_EXTREMES (100点):
∿ · · · ∿ · · · ∿ · · · ∿
↑ 只保留部分周期的极值,波形不连续
```

**噪声信号降采样效果**:

```
原始波形 (1000点):
⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡ (随机噪声)

HYBRID_ENVELOPE (100点):
⚡ ⚡⚡  ⚡   ⚡⚡⚡ ⚡  ⚡
↑ 可能在某些区域点聚集,某些区域稀疏

UNIFORM_WITH_EXTREMES (100点):
⚡ · ⚡ · ⚡ · ⚡ · ⚡ · ⚡ · ⚡ · ⚡
↑ 时间轴均匀分布,极值点保留,无聚集
```

### 9.4 实际应用场景举例

#### 9.4.1 场景一: 电机转速监控 (周期性信号)

**数据特征**:

- 信号类型: PERIODIC
- 原始点数: 10000点
- 目标点数: 500点
- 压缩比: 20:1

**算法选择**: `HYBRID_ENVELOPE`

**理由**:

```
电机转速呈现周期性波动,需要完整展示每个周期的峰谷:
- 40%配额 (200点) → 保留每个周期的最大最小转速
- 30%配额 (150点) → 保留平均转速趋势
- 30%配额 (150点) → 补充细节

结果: 工程师能清晰看到每个周期的转速波动范围
```

**如果用 UNIFORM_WITH_EXTREMES**:

```
只保留 15% × 500 = 75个局部极值点
→ 可能只覆盖部分周期的峰谷
→ 无法完整展示转速波动规律
→ ❌ 不适合
```

---

#### 9.4.2 场景二: 股票价格监控 (噪声信号)

**数据特征**:

- 信号类型: TREND_NOISE
- 原始点数: 50000点 (一年的日K线)
- 目标点数: 1000点
- 压缩比: 50:1

**算法选择**: `UNIFORM_WITH_EXTREMES`

**理由**:

```
股票价格是随机波动 + 趋势的混合信号:
- 全局极值: 保留年度最高价和最低价
- 15%局部极值 (150点): 保留重要的波峰波谷
- 85%均匀点 (850点): 均匀分布在时间轴上,避免某些月份数据缺失

结果: 既保留了关键极值,又确保时间轴分布均匀
```

**如果用 HYBRID_ENVELOPE**:

```
40%配额用于包络 → 但股票价格不是规律的周期性波动
30%配额用于中心带 → 对随机噪声意义不大
→ 可能在某些时间段点聚集,某些时间段稀疏
→ ❌ 不适合
```

---

#### 9.4.3 场景三: 调幅信号 (振幅增长的正弦波)

**数据特征**:

- 信号类型: AMPLITUDE_MODULATED
- 原始点数: 20000点
- 目标点数: 800点
- 压缩比: 25:1

**算法选择**: `HYBRID_ENVELOPE`

**理由**:

```
调幅信号的振幅随时间线性增长:
- 40%包络点 (320点): 勾勒出上下边界的增长趋势
- 30%中心带点 (240点): 保留中心线的变化 ← 关键!
- 30%填充点 (240点): 补充细节

结果: 清晰展示振幅从小到大的增长过程
```

**如果用 UNIFORM_WITH_EXTREMES**:

```
只保留全局最大峰和最小谷 + 15%局部极值
→ 缺少中心带采样
→ 振幅增长的中间过渡信息丢失
→ ❌ 不适合
```

### 9.5 可以替代的特殊情况

虽然两个算法各有专长,但在以下情况下可以考虑替代:

#### 9.5.1 压缩比很低 (< 5)

**示例**: 1000点 → 200点

```
UNIFORM_WITH_EXTREMES 的 15%局部极值 = 30个点
→ 可能足够覆盖主要的波峰波谷
→ 此时可以替代 HYBRID_ENVELOPE
```

#### 9.5.2 周期数很少 (< 3个周期)

**示例**: 只有2个周期的正弦波

```
全局极值 (2个) + 15%局部极值 (可能10-15个)
→ 足够覆盖2个周期的所有峰谷
→ 此时可以替代 HYBRID_ENVELOPE
```

#### 9.5.3 只需要极值,不需要完整包络

**示例**: 只关心最大值和最小值,不关心波形

```
UNIFORM_WITH_EXTREMES 更合适
→ 极值保护更强
→ 时间分布更均匀
```

### 9.6 算法选择决策树

```
开始
  ↓
是否为周期性信号? (PERIODIC / AMPLITUDE_MODULATED)
  ↓ 是
  → 使用 HYBRID_ENVELOPE
     理由: 需要完整的包络线和中心带
  
  ↓ 否
是否为噪声/复杂信号? (NOISE / TREND_NOISE / COMPLEX)
  ↓ 是
  → 使用 UNIFORM_WITH_EXTREMES
     理由: 需要均匀分布,避免点聚集
  
  ↓ 否
  → 使用其他算法 (LTTB / PEAK_DETECTION 等)
```

### 9.7 总结与建议

#### 核心结论:

1. **HYBRID_ENVELOPE** 和 **UNIFORM_WITH_EXTREMES** **不能相互替代**
2. 两者设计目标不同,各有专长
3. 保留两个算法,根据信号类型自动选择,是最佳实践

#### 关键差异:

| 维度        | HYBRID_ENVELOPE | UNIFORM_WITH_EXTREMES |
|-----------|-----------------|-----------------------|
| **包络保护**  | ⭐⭐⭐⭐⭐ (40%配额)   | ⭐⭐⭐ (15%配额)           |
| **中心带采样** | ⭐⭐⭐⭐⭐ (30%配额)   | ❌ 无                   |
| **时间均匀性** | ⭐⭐⭐ (可能不均)      | ⭐⭐⭐⭐⭐ (严格均匀)          |
| **极值保护**  | ⭐⭐⭐⭐ (包络中包含)    | ⭐⭐⭐⭐⭐ (专门保护)          |
| **周期性信号** | ⭐⭐⭐⭐⭐ 最佳        | ⭐⭐⭐ 一般                |
| **噪声信号**  | ⭐⭐⭐ 可能聚集        | ⭐⭐⭐⭐⭐ 最佳              |

#### 最佳实践:

```java
// 保留两个算法,根据信号类型自动选择
if(signalType ==SignalType.PERIODIC ||
signalType ==SignalType.AMPLITUDE_MODULATED){
        return DownsamplingAlgorithm.HYBRID_ENVELOPE;
}

        if(signalType ==SignalType.NOISE ||
signalType ==SignalType.TREND_NOISE ||
signalType ==SignalType.COMPLEX){
        return DownsamplingAlgorithm.UNIFORM_WITH_EXTREMES;
}
```

**这正是 v5.0 版本的核心设计理念**: 让算法自动识别信号特征,选择最合适的降采样策略,确保在各种场景下都能获得最佳的视觉效果和数据保真度。

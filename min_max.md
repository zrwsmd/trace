# MinMaxDownsampler 示例（Min/Max Downsampling）

## 场景设定

- 原始数据 `data`：12 个点。
- 目标点数 `threshold`：为了让分桶更合理，这里修正为 **6** 个点（因为每个桶输出 2 个点：min 和 max）。

原始数据点列表（X, Y）：

```text
[(0, 5), (1, 8), (2, 6), (3, 2),
 (4, 9), (5, 4), (6, 7), (7, 3),
 (8, 5), (9, 6), (10, 1), (11, 8)]
```

> 为了便于理解，下文按“未来的分桶结果”对数据分组。

---

## `downsample(data, threshold)` 执行步骤

### 1) 计算分桶数量

- `threshold = 6`
- 每个桶选出 2 个点（`min` 和 `max`）
- 所以桶数量：

```text
bucketCount = threshold / 2 = 6 / 2 = 3
```

### 2) 计算每个桶的大小

- 数据点总数：`dataSize = 12`
- 桶数：`bucketCount = 3`
- 每个桶大小：

```text
step = dataSize / bucketCount = 12 / 3 = 4
```

### 3) 遍历所有桶并寻找极值

#### 循环 1：处理第一个桶（i = 0）

- 索引范围：0 ~ 3
- 数据：`[(0, 5), (1, 8), (2, 6), (3, 2)]`
- 极值：
  - `minPoint = (3, 2)`
  - `maxPoint = (1, 8)`
- 为保证时间顺序：`maxPoint.x (1)` 在 `minPoint.x (3)` 之前
- 结果：

```text
sampledPoints = [(1, 8), (3, 2)]
```

---

#### 循环 2：处理第二个桶（i = 1）

- 索引范围：4 ~ 7
- 数据：`[(4, 9), (5, 4), (6, 7), (7, 3)]`
- 极值：
  - `minPoint = (7, 3)`
  - `maxPoint = (4, 9)`
- 为保证时间顺序：先放 `maxPoint` 再放 `minPoint`
- 结果：

```text
sampledPoints = [(1, 8), (3, 2), (4, 9), (7, 3)]
```

---

#### 循环 3：处理第三个桶（i = 2）

- 索引范围：8 ~ 11
- 数据：`[(8, 5), (9, 6), (10, 1), (11, 8)]`
- 极值：
  - `minPoint = (10, 1)`
  - `maxPoint = (11, 8)`
- 时间顺序正常：先 `minPoint` 后 `maxPoint`
- 结果：

```text
sampledPoints = [(1, 8), (3, 2), (4, 9), (7, 3), (10, 1), (11, 8)]
```

---

## 4) 返回最终结果

最终返回的 `sampledPoints` 共 **6** 个点，它们构成了原始 12 个点数据在各桶内的上下包络（min/max），并且保持了时间顺序。

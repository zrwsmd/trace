# AdaptiveDownsamplingSelector 代码实现逻辑详解 (v4.0)

本文档旨在解析 `AdaptiveDownsamplingSelector.java` 的底层实现逻辑，说明它是如何通过数学特征分析来实现智能降采样的。

---

## 1. 核心流程控制 (`downsample` 方法)

这是算法的总入口，它决定了数据流向哪条处理路径。

### 逻辑逻辑：

1. **小数据集直通**：如果原始点数已经很接近目标点数（`n <= targetCount + 2`），直接返回原始数据，不做处理。
2. **窗口化路径**：如果数据量较大（超过 400 点），进入核心的 `windowBasedDownsamplingV4` 流程。
3. **全局路径**：如果数据量中等，直接进行全局特征分析并应用单一算法。
4. **归一化兜底**：无论中间过程产生多少点，最后通过 `normalizeToTargetV4` 确保输出点数精确等于 `targetCount`。

---

## 2. 窗口化降采样逻辑 (`windowBasedDownsamplingV4`)

这是解决“长周期查询稀疏”和“特征丢失”的核心逻辑。

### 第一步：自适应窗口划分

算法不使用固定窗口，而是根据**压缩比**调整窗口大小：

* **例子**：如果用户查 1 小时数据（10万点），请求 2000 点（压缩比 50x），窗口会自动调大到 400 点，以获得更宏观的统计特征。

### 第二步：特征驱动的权重分配 (`allocatePointsV4`)

这是算法最聪明的地方。它会对每个窗口计算一个“重要性权重”。

* **计算逻辑**：`权重 = 基础(0.3) + 归一化波动率 + 形状复杂度加成 + 突变加成`。
* **例子 (r0 vs r1)**：
    * `r1` 是直线，波动率为 0，线性度为 1，最终权重可能只有 **0.3**。
    * `r0` 是正弦波，波动率高且具有周期性，最终权重可能高达 **2.5**。
    * **结果**：在分配 2000 个点的配额时，`r0` 所在的窗口会分到比 `r1` 多出数倍的点数，确保波形细节清晰。

### 第三步：最小密度保护

* **代码逻辑**：`MIN_DENSITY_RATIO = 0.02`。
* **意义**：即使某个窗口非常平，也强制分配 2% 的点。这保证了在图表中不会出现完全的断线或大片空白。

---

## 3. 混合包络算法 (`hybridEnvelopeDownsampling`)

这是专门为 `r0` 这种周期性调幅信号设计的。

### 核心策略 (4:3:3 比例)：

当算法识别出信号是 `PERIODIC` 或 `AMPLITUDE_MODULATED` 且压缩比很高时，会启动此模式：

1. **包络线 (40%)**：使用 `MinMax` 提取这段时间内的最高值和最低值。
2. **中心带 (30%)**：通过 `sampleCentralBand` 采样靠近均值的点。
3. **细节填充 (30%)**：使用 `LTTB` 或均匀采样填充。

* **例子 (r0)**：如果不这样做，`LTTB` 可能会只选几个零点，导致波形变细。通过这种 4:3:3 的组合，`r0`
  在图表上会显示为一个实心的、饱满的蓝色带状波形，完美保留了振幅包络。

---

## 4. 严格归一化逻辑 (`normalizeToTargetV4`)

这是为了解决“返回点数不准确”的问题。

### 智能补点 (`fillGaps`)：

如果算法执行完发现还差 50 个点才到 2000：

1. 它会扫描整个时间轴，找到点与点之间**时间跨度最大**的间隙（Gap）。
2. 从原始数据中精准找到落在这个间隙里的点补进去。
3. **效果**：不仅点数准了，还填补了数据分布最稀疏的地方。

### 均匀裁剪 (`balancedUniformTrim`)：

如果多了 10 个点：

1. 它不直接删掉最后 10 个，而是计算步长，全局均匀地剔除 10 个点。
2. **效果**：保持了波形的整体分布，不会造成局部的视觉跳变。

---

## 5. 总结

该类的代码逻辑可以概括为：**先看全局定策略，再分窗口算权重，最后混合算法保特征，最后精准补齐定数量。** 这种多层级的处理确保了在处理
codesys trace 这种高频信号时，既能看清全局包络，又能缩放查看细节。
